// app/api/quizzes/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

// Initialize Prisma client
const prisma = new PrismaClient();

// Define the quiz types (consider moving to a shared types file later)
type Question = {
  id: string;
  text: string;
  options: string[];
  correctAnswer: string;
  quizId?: string; // Added for database relations
};

type Quiz = {
  id: string;
  title: string;
  category: string;
  questions: Question[];
};

// Helper to get quizzes from the database
const getQuizzesFromDB = async (): Promise<Quiz[]> => {
  try {
    // Get all quizzes with their questions
    const quizzes = await prisma.quiz.findMany({
      include: {
        questions: true,
      },
    });
    
    // Transform the data to match the expected format
    return quizzes.map(quiz => ({
      id: quiz.id,
      title: quiz.title,
      category: quiz.category,
      questions: quiz.questions.map(question => ({
        id: question.id,
        text: question.text,
        options: question.options as string[], // Options stored as a JSON array in DB
        correctAnswer: question.correctAnswer,
      })),
    }));
  } catch (error) {
    console.error("Failed to read quizzes from database:", error);
    throw new Error("Could not retrieve quiz data from database.");
  }
};

// Helper to add a new quiz to the database
const addQuizToDB = async (quiz: Quiz): Promise<Quiz> => {
  try {
    // Create the quiz and its questions in a transaction
    const result = await prisma.$transaction(async (tx) => {
      // Create the quiz
      const createdQuiz = await tx.quiz.create({
        data: {
          id: quiz.id,
          title: quiz.title,
          category: quiz.category,
          // Create the questions related to this quiz
          questions: {
            create: quiz.questions.map(question => ({
              id: question.id,
              text: question.text,
              options: question.options, // This will be stored as a JSON array
              correctAnswer: question.correctAnswer,
            })),
          },
        },
        // Include questions in the return value
        include: {
          questions: true,
        },
      });

      // Transform the response to match the expected Quiz type
      return {
        id: createdQuiz.id,
        title: createdQuiz.title,
        category: createdQuiz.category,
        questions: createdQuiz.questions.map(question => ({
          id: question.id,
          text: question.text,
          options: question.options as string[],
          correctAnswer: question.correctAnswer,
        })),
      };
    });

    return result;
  } catch (error) {
    console.error("Failed to add quiz to database:", error);
    throw new Error("Could not save quiz data to database.");
  }
};

// --- API Route Handlers ---

// GET: Retrieve all quizzes
export async function GET() {
  try {
    const quizzes = await getQuizzesFromDB();
    return NextResponse.json(quizzes);
  } catch (error: any) {
    // Use the error message generated by the helper functions
    return NextResponse.json({ error: error.message || 'Failed to fetch quizzes' }, { status: 500 });
  }
}

// POST: Add a new quiz
export async function POST(request: NextRequest) {
  try {
    let newQuizData: Partial<Quiz>;

    // 1. Parse incoming data
    try {
      newQuizData = await request.json();
    } catch (error) {
      return NextResponse.json({ error: 'Invalid JSON data in request body' }, { status: 400 });
    }

    // 2. Basic Validation (enhance as needed)
    if (!newQuizData.title || typeof newQuizData.title !== 'string' || newQuizData.title.trim() === '') {
      return NextResponse.json({ error: 'Quiz title is required' }, { status: 400 });
    }
    if (!newQuizData.category || typeof newQuizData.category !== 'string' || newQuizData.category.trim() === '') {
      // Optionally assign a default category or return error
      return NextResponse.json({ error: 'Quiz category is required' }, { status: 400 });
    }
    if (!newQuizData.questions || !Array.isArray(newQuizData.questions) || newQuizData.questions.length === 0) {
      return NextResponse.json({ error: 'Quiz must have at least one question' }, { status: 400 });
    }
    // Add more validation for question structure if necessary

    // 3. Prepare the final quiz object
    const finalQuiz: Quiz = {
      // Generate a simple unique ID (consider UUID for production)
      id: Date.now().toString(36) + Math.random().toString(36).substring(2, 9),
      title: newQuizData.title.trim(),
      category: newQuizData.category.trim(),
      // Ensure questions have IDs and clean data (optional deep validation)
      questions: newQuizData.questions.map((q: any, index: number) => ({
        id: q.id || `${Date.now()}-${index}`, // Assign ID if missing
        text: q.text?.trim() || '',
        options: Array.isArray(q.options) ? q.options.map((opt: any) => String(opt).trim()) : [],
        correctAnswer: q.correctAnswer?.trim() || '',
      })),
    };

    // 4. Add the new quiz to the database
    const createdQuiz = await addQuizToDB(finalQuiz);

    // 5. Return the newly created quiz with 201 status
    return NextResponse.json(createdQuiz, { status: 201 });

  } catch (error: any) {
     // Catch errors from database operations or unexpected issues
    console.error("[API POST Error]", error);
    return NextResponse.json({ error: error.message || 'Failed to create quiz' }, { status: 500 });
  }
}