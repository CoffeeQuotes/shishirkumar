// app/api/quizzes/route.ts
import { NextRequest, NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
import { writeFile, readFile, mkdir } from 'fs/promises'; // Use async file system methods

// Define the quiz types (consider moving to a shared types file later)
type Question = {
  id: string;
  text: string;
  options: string[];
  correctAnswer: string;
};

type Quiz = {
  id: string;
  title: string;
  category: string;
  questions: Question[];
};

// Path to the JSON file - ensure it's correct relative to project root
// Using 'data' directory is a good practice
const dataDirectory = path.join(process.cwd(), 'data');
const dataFilePath = path.join(dataDirectory, 'quizzes.json');

// Ensure the data directory exists (async version)
const ensureDirectoryExists = async () => {
  try {
    await mkdir(dataDirectory, { recursive: true });
  } catch (error: any) {
    // Ignore error if directory already exists
    if (error.code !== 'EEXIST') {
      console.error("Failed to create data directory:", error);
      throw new Error("Could not ensure data directory exists."); // Re-throw for server error
    }
  }
};

// Helper to read quizzes from the file (async)
const readQuizzesFromFile = async (): Promise<Quiz[]> => {
  try {
    await ensureDirectoryExists(); // Make sure directory is there before reading
    // Check if file exists first to avoid error on first run
    if (!fs.existsSync(dataFilePath)) {
        return []; // Return empty array if file doesn't exist
    }
    const jsonData = await readFile(dataFilePath, 'utf-8');
    // Handle empty file case
    if (!jsonData.trim()) {
        return [];
    }
    const quizzes = JSON.parse(jsonData);
    // Basic validation if it's an array
    return Array.isArray(quizzes) ? quizzes : [];
  } catch (error: any) {
    // Specifically handle file not found during read attempt (though check above should prevent)
    if (error.code === 'ENOENT') {
      return []; // File doesn't exist, return empty array
    }
    // Handle JSON parsing errors
    if (error instanceof SyntaxError) {
        console.error("Error parsing quizzes.json:", error);
        // Decide how to handle: return empty array or throw error?
        // Returning empty might be safer, but masks data corruption. Throwing is clearer.
        throw new Error("Failed to parse quiz data file. File might be corrupted.");
    }
    console.error("Failed to read quizzes file:", error);
    // Re-throw other unexpected errors to be caught by the handler
    throw new Error("Could not read quiz data.");
  }
};

// Helper to write quizzes to the file (async)
const writeQuizzesToFile = async (quizzes: Quiz[]): Promise<void> => {
  try {
    await ensureDirectoryExists();
    const jsonData = JSON.stringify(quizzes, null, 2); // Pretty print JSON
    await writeFile(dataFilePath, jsonData, 'utf-8');
  } catch (error) {
    console.error("Failed to write quizzes file:", error);
    throw new Error("Could not save quiz data."); // Propagate error
  }
};

// --- API Route Handlers ---

// GET: Retrieve all quizzes
export async function GET() {
  try {
    const quizzes = await readQuizzesFromFile();
    return NextResponse.json(quizzes);
  } catch (error: any) {
    // Use the error message generated by the helper functions
    return NextResponse.json({ error: error.message || 'Failed to fetch quizzes' }, { status: 500 });
  }
}

// POST: Add a new quiz
export async function POST(request: NextRequest) {
  try {
    let newQuizData: Partial<Quiz>;

    // 1. Parse incoming data
    try {
      newQuizData = await request.json();
    } catch (error) {
      return NextResponse.json({ error: 'Invalid JSON data in request body' }, { status: 400 });
    }

    // 2. Basic Validation (enhance as needed)
    if (!newQuizData.title || typeof newQuizData.title !== 'string' || newQuizData.title.trim() === '') {
      return NextResponse.json({ error: 'Quiz title is required' }, { status: 400 });
    }
    if (!newQuizData.category || typeof newQuizData.category !== 'string' || newQuizData.category.trim() === '') {
      // Optionally assign a default category or return error
      return NextResponse.json({ error: 'Quiz category is required' }, { status: 400 });
    }
    if (!newQuizData.questions || !Array.isArray(newQuizData.questions) || newQuizData.questions.length === 0) {
      return NextResponse.json({ error: 'Quiz must have at least one question' }, { status: 400 });
    }
    // Add more validation for question structure if necessary

    // 3. Read existing quizzes
    const quizzes = await readQuizzesFromFile(); // Handles reading errors

    // 4. Prepare the final quiz object
    const finalQuiz: Quiz = {
      // Generate a simple unique ID (consider UUID for production)
      id: Date.now().toString(36) + Math.random().toString(36).substring(2, 9),
      title: newQuizData.title.trim(),
      category: newQuizData.category.trim(),
      // Ensure questions have IDs and clean data (optional deep validation)
      questions: newQuizData.questions.map((q: any, index: number) => ({
        id: q.id || `${Date.now()}-${index}`, // Assign ID if missing
        text: q.text?.trim() || '',
        options: Array.isArray(q.options) ? q.options.map((opt: any) => String(opt).trim()) : [],
        correctAnswer: q.correctAnswer?.trim() || '',
      })),
    };

    // 5. Add the new quiz
    quizzes.push(finalQuiz);

    // 6. Write updated data back to file
    await writeQuizzesToFile(quizzes); // Handles writing errors

    // 7. Return the newly created quiz with 201 status
    return NextResponse.json(finalQuiz, { status: 201 });

  } catch (error: any) {
     // Catch errors from read/write helpers or unexpected issues
    console.error("[API POST Error]", error);
    return NextResponse.json({ error: error.message || 'Failed to create quiz' }, { status: 500 });
  }
}
